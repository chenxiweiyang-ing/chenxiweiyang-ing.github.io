<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-28T01:56:14.406Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yajuan Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue项目遇到的兼容问题</title>
    <link href="http://yoursite.com/2018/08/28/vuex-compatibility/"/>
    <id>http://yoursite.com/2018/08/28/vuex-compatibility/</id>
    <published>2018-08-28T01:56:14.397Z</published>
    <updated>2018-08-28T01:56:14.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、IE报vuex-或-Promise-错误"><a href="#一、IE报vuex-或-Promise-错误" class="headerlink" title="一、IE报vuex 或 Promise 错误"></a>一、IE报vuex 或 Promise 错误</h2><p>解决方法：<br>第一步：安装 babel-polyfill 。 babel-polyfill可以模拟ES6使用的环境，可以使用ES6的所有新方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save babel-polyfill</span><br></pre></td></tr></table></figure></p><p>第二步：<br>第一种：在webpack.base.config.js文件中，将<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">entry: &#123;</span><br><span class="line">app: <span class="string">'./src/main.js'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>改为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">entry: &#123;</span><br><span class="line">app: [<span class="string">"babel-polyfill"</span>, <span class="string">"./src/main.js"</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>第二种：在main.js里全局引入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">'babel-polyfill'</span></span><br></pre></td></tr></table></figure></p><h2 id="二、vue兼容IE9-IE10报语法错误，打不开页面"><a href="#二、vue兼容IE9-IE10报语法错误，打不开页面" class="headerlink" title="二、vue兼容IE9/IE10报语法错误，打不开页面"></a>二、vue兼容IE9/IE10报语法错误，打不开页面</h2><p>这个锅其实是 webpack-dev-server的问题。它里面通过socket给浏览器的代码有 部分 es6的代码 如 const 这些。然后这种东西ie11以下并不认识。<br>Webpack Dev Server 官方已经放弃了旧版浏览器的支持，所以要么回滚到 <a href="mailto:webpack-dev-server@2.7.1" target="_blank" rel="noopener">webpack-dev-server@2.7.1</a> 要么放弃旧版浏览器。</p><h2 id="三、ie9与ie10-Vue-warn-Error-in-directive-transfer-dom-inserted-hook-“TypeError-无法获取未定义或-null-引用的属性“transfer””"><a href="#三、ie9与ie10-Vue-warn-Error-in-directive-transfer-dom-inserted-hook-“TypeError-无法获取未定义或-null-引用的属性“transfer””" class="headerlink" title="三、ie9与ie10[Vue warn]: Error in directive transfer-dom inserted hook: “TypeError: 无法获取未定义或 null 引用的属性“transfer””"></a>三、ie9与ie10[Vue warn]: Error in directive transfer-dom inserted hook: “TypeError: 无法获取未定义或 null 引用的属性“transfer””</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var isIE = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> (window.navigator.userAgent.indexOf(<span class="string">"MSIE"</span>)&gt;=1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修复IE10及以下版本不支持dataset属性的问题，兼容transfer-dom.js中使用了dataset的问题</span><br><span class="line"><span class="keyword">if</span> (isIE() &amp;&amp; window.HTMLElement) &#123;</span><br><span class="line">  <span class="keyword">if</span> (Object.getOwnPropertyNames(HTMLElement.prototype).indexOf(<span class="string">'dataset'</span>) === -1) &#123;</span><br><span class="line">    Object.defineProperty(HTMLElement.prototype, <span class="string">'dataset'</span>, &#123;</span><br><span class="line">      get: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        var attributes = this.attributes;</span><br><span class="line">        var name = [],</span><br><span class="line">          value = [];</span><br><span class="line">        var obj = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (var i = 0; i &lt; attributes.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (attributes[i].nodeName.slice(0, 5) == <span class="string">'data-'</span>) &#123;</span><br><span class="line">            name.push(attributes[i].nodeName.slice(5));</span><br><span class="line">            value.push(attributes[i].nodeValue);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (var j = 0; j &lt; name.length; j++) &#123;</span><br><span class="line">          obj[name[j]] = value[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> obj;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、IE报vuex-或-Promise-错误&quot;&gt;&lt;a href=&quot;#一、IE报vuex-或-Promise-错误&quot; class=&quot;headerlink&quot; title=&quot;一、IE报vuex 或 Promise 错误&quot;&gt;&lt;/a&gt;一、IE报vuex 或 Promise 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端跨域的几种方法</title>
    <link href="http://yoursite.com/2018/08/27/cross-domain/"/>
    <id>http://yoursite.com/2018/08/27/cross-domain/</id>
    <published>2018-08-27T02:58:02.880Z</published>
    <updated>2018-08-27T02:58:02.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、通过jsonp跨域"><a href="#一、通过jsonp跨域" class="headerlink" title="一、通过jsonp跨域"></a>一、通过jsonp跨域</h2><p>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</p><h3 id="1）原生实现："><a href="#1）原生实现：" class="headerlink" title="1）原生实现："></a>1）原生实现：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   var script = document.createElement(<span class="string">'script'</span>);</span><br><span class="line">   script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line"></span><br><span class="line">   // 传参并指定回调执行函数为onBack</span><br><span class="line">   script.src = <span class="string">'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack'</span>;</span><br><span class="line">   document.head.appendChild(script);</span><br><span class="line"></span><br><span class="line">   // 回调执行函数</span><br><span class="line">   <span class="keyword">function</span> onBack(res) &#123;</span><br><span class="line">       alert(JSON.stringify(res));</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>服务端返回如下（返回时即执行全局函数）：</p><p>onBack({“status”: true, “user”: “admin”})</p><h3 id="2）jquery-ajax："><a href="#2）jquery-ajax：" class="headerlink" title="2）jquery ajax："></a>2）jquery ajax：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">'http://www.domain2.com:8080/login'</span>,</span><br><span class="line">    <span class="built_in">type</span>: <span class="string">'get'</span>,</span><br><span class="line">    dataType: <span class="string">'jsonp'</span>,  // 请求方式为jsonp</span><br><span class="line">    jsonpCallback: <span class="string">"onBack"</span>,    // 自定义回调函数名</span><br><span class="line">    data: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> jsonp缺点：只能实现get一种请求。</p><h2 id="二、-document-domain-iframe跨域"><a href="#二、-document-domain-iframe跨域" class="headerlink" title="二、 document.domain + iframe跨域"></a>二、 document.domain + iframe跨域</h2><p>此方案仅限主域相同，子域不同的跨域应用场景。</p><p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p><h3 id="1）父窗口：-www-domain-com-a-html"><a href="#1）父窗口：-www-domain-com-a-html" class="headerlink" title="1）父窗口：(www.domain.com/a.html)"></a>1）父窗口：(<a href="http://www.domain.com/a.html" target="_blank" rel="noopener">www.domain.com/a.html</a>)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=<span class="string">"iframe"</span> src=<span class="string">"http://child.domain.com/b.html"</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.domain = <span class="string">'domain.com'</span>;</span><br><span class="line">    var user = <span class="string">'admin'</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="2）子窗口：-child-domain-com-b-html"><a href="#2）子窗口：-child-domain-com-b-html" class="headerlink" title="2）子窗口：(child.domain.com/b.html)"></a>2）子窗口：(child.domain.com/b.html)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    document.domain = <span class="string">'domain.com'</span>;</span><br><span class="line">    // 获取父窗口中变量</span><br><span class="line">    alert(<span class="string">'get js data from parent ---&gt; '</span> + window.parent.user);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="三、-location-hash-iframe跨域"><a href="#三、-location-hash-iframe跨域" class="headerlink" title="三、 location.hash + iframe跨域"></a>三、 location.hash + iframe跨域</h2><p>实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p><p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p><h3 id="1）a-html：-www-domain1-com-a-html"><a href="#1）a-html：-www-domain1-com-a-html" class="headerlink" title="1）a.html：(www.domain1.com/a.html)"></a>1）a.html：(<a href="http://www.domain1.com/a.html" target="_blank" rel="noopener">www.domain1.com/a.html</a>)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=<span class="string">"iframe"</span> src=<span class="string">"http://www.domain2.com/b.html"</span> style=<span class="string">"display:none;"</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var iframe = document.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line"></span><br><span class="line">    // 向b.html传<span class="built_in">hash</span>值</span><br><span class="line">    setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        iframe.src = iframe.src + <span class="string">'#user=admin'</span>;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    </span><br><span class="line">    // 开放给同域c.html的回调方法</span><br><span class="line">    <span class="keyword">function</span> onCallback(res) &#123;</span><br><span class="line">        alert(<span class="string">'data from c.html ---&gt; '</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="2）b-html：-www-domain2-com-b-html"><a href="#2）b-html：-www-domain2-com-b-html" class="headerlink" title="2）b.html：(www.domain2.com/b.html)"></a>2）b.html：(<a href="http://www.domain2.com/b.html" target="_blank" rel="noopener">www.domain2.com/b.html</a>)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;iframe id=<span class="string">"iframe"</span> src=<span class="string">"http://www.domain1.com/c.html"</span> style=<span class="string">"display:none;"</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var iframe = document.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line"></span><br><span class="line">    // 监听a.html传来的<span class="built_in">hash</span>值，再传给c.html</span><br><span class="line">    window.onhashchange = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        iframe.src = iframe.src + location.hash;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="3）c-html：-www-domain1-com-c-html"><a href="#3）c-html：-www-domain1-com-c-html" class="headerlink" title="3）c.html：(www.domain1.com/c.html)"></a>3）c.html：(<a href="http://www.domain1.com/c.html" target="_blank" rel="noopener">www.domain1.com/c.html</a>)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 监听b.html传来的<span class="built_in">hash</span>值</span><br><span class="line">    window.onhashchange = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        // 再通过操作同域a.html的js回调，将结果传回</span><br><span class="line">        window.parent.parent.onCallback(<span class="string">'hello: '</span> + location.hash.replace(<span class="string">'#user='</span>, <span class="string">''</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="四、-window-name-iframe跨域"><a href="#四、-window-name-iframe跨域" class="headerlink" title="四、 window.name + iframe跨域"></a>四、 window.name + iframe跨域</h2><p>关键点：window.name在页面的生命周期里共享一个window.name;<br>兼容性：所有浏览器都支持;</p><p>优点：<br>　最简单的利用了浏览器的特性来做到不同域之间的数据传递；<br>　不需要前端和后端的特殊配制；</p><p>缺点：<br>　大小限制：window.name最大size是2M左右，不同浏览器中会有不同约定；<br>　安全性：当前页面所有window都可以修改，很不安全；<br>　数据类型：传递数据只能限于字符串，如果是对象或者其他会自动被转化为字符串;</p><p>使用方式：修改window.name的值即可；</p><h3 id="1）a-html：-www-domain1-com-a-html-1"><a href="#1）a-html：-www-domain1-com-a-html-1" class="headerlink" title="1）a.html：(www.domain1.com/a.html)"></a>1）a.html：(<a href="http://www.domain1.com/a.html" target="_blank" rel="noopener">www.domain1.com/a.html</a>)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var proxy = <span class="keyword">function</span>(url, callback) &#123;</span><br><span class="line">    var state = 0;</span><br><span class="line">    var iframe = document.createElement(<span class="string">'iframe'</span>);</span><br><span class="line"></span><br><span class="line">    // 加载跨域页面</span><br><span class="line">    iframe.src = url;</span><br><span class="line"></span><br><span class="line">    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span><br><span class="line">    iframe.onload = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (state === 1) &#123;</span><br><span class="line">            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span><br><span class="line">            callback(iframe.contentWindow.name);</span><br><span class="line">            destoryFrame();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === 0) &#123;</span><br><span class="line">            // 第1次onload(跨域页)成功后，切换到同域代理页面</span><br><span class="line">            iframe.contentWindow.location = <span class="string">'http://www.domain1.com/proxy.html'</span>;</span><br><span class="line">            state = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    document.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">destoryFrame</span></span>() &#123;</span><br><span class="line">        iframe.contentWindow.document.write(<span class="string">''</span>);</span><br><span class="line">        iframe.contentWindow.close();</span><br><span class="line">        document.body.removeChild(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 请求跨域b页面数据</span><br><span class="line">proxy(<span class="string">'http://www.domain2.com/b.html'</span>, <span class="keyword">function</span>(data)&#123;</span><br><span class="line">    alert(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2.）proxy.html：(<a href="http://www.domain1.com/proxy..." target="_blank" rel="noopener">www.domain1.com/proxy...</a>.<br>中间代理页，与a.html同域，内容为空即可。</p><p>3.）b.html：(<a href="http://www.domain2.com/b.html" target="_blank" rel="noopener">www.domain2.com/b.html</a>)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.name = <span class="string">'This is domain2 data!'</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h2 id="五、-postMessage跨域"><a href="#五、-postMessage跨域" class="headerlink" title="五、 postMessage跨域"></a>五、 postMessage跨域</h2><p>关键点：<br>　postMessage是h5引入的一个新概念，现在也在进一步的推广和发展中，他进行了一系列的封装，我们可以通过window.postMessage的方式进行使用，并可以监听其发送的消息；<br>兼容性：移动端可以放心用，但是pc端需要做降级处理<br>优点<br>　不需要后端介入就可以做到跨域，一个函数外加两个参数（请求url，发送数据）就可以搞定；<br>　移动端兼容性好；<br>缺点<br>　无法做到一对一的传递方式：监听中需要做很多消息的识别，由于postMessage发出的消息对于同一个页面的不同功能相当于一个广播的过程，该页面的所有onmessage都会收到，所以需要做消息的判断；<br>安全性问题：三方可以通过截获，注入html或者脚本的形式监听到消息，从而能够做到篡改的效果，所以在postMessage和onmessage中一定要做好这方面的限制；<br>　发送的数据会通过结构化克隆算法进行序列化，所以只有满足该算法要求的参数才能够被解析，否则会报错，如function就不能当作参数进行传递；<br>使用方式：通信的函数，sendMessage负责发送消息，bindEvent负责消息的监听并处理，可以通过代码来做一个大致了解；</p><h3 id="1）a-html：-www-domain1-com-a-html-2"><a href="#1）a-html：-www-domain1-com-a-html-2" class="headerlink" title="1）a.html：(www.domain1.com/a.html)"></a>1）a.html：(<a href="http://www.domain1.com/a.html" target="_blank" rel="noopener">www.domain1.com/a.html</a>)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;iframe id=<span class="string">"iframe"</span> src=<span class="string">"http://www.domain2.com/b.html"</span> style=<span class="string">"display:none;"</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;       </span><br><span class="line">    var iframe = document.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line">    iframe.onload = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        var data = &#123;</span><br><span class="line">            name: <span class="string">'aym'</span></span><br><span class="line">        &#125;;</span><br><span class="line">        // 向domain2传送跨域数据</span><br><span class="line">        iframe.contentWindow.postMessage(JSON.stringify(data), <span class="string">'http://www.domain2.com'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 接受domain2返回数据</span><br><span class="line">    window.addEventListener(<span class="string">'message'</span>, <span class="keyword">function</span>(e) &#123;</span><br><span class="line">        alert(<span class="string">'data from domain2 ---&gt; '</span> + e.data);</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="2）b-html：-www-domain2-com-b-html-1"><a href="#2）b-html：-www-domain2-com-b-html-1" class="headerlink" title="2）b.html：(www.domain2.com/b.html)"></a>2）b.html：(<a href="http://www.domain2.com/b.html" target="_blank" rel="noopener">www.domain2.com/b.html</a>)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 接收domain1的数据</span><br><span class="line">    window.addEventListener(<span class="string">'message'</span>, <span class="keyword">function</span>(e) &#123;</span><br><span class="line">        alert(<span class="string">'data from domain1 ---&gt; '</span> + e.data);</span><br><span class="line"></span><br><span class="line">        var data = JSON.parse(e.data);</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            data.number = 16;</span><br><span class="line"></span><br><span class="line">            // 处理后再发回domain1</span><br><span class="line">            window.parent.postMessage(JSON.stringify(data), <span class="string">'http://www.domain1.com'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="六、-跨域资源共享（CORS）"><a href="#六、-跨域资源共享（CORS）" class="headerlink" title="六、 跨域资源共享（CORS）"></a>六、 跨域资源共享（CORS）</h2><p>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置。<br>带cookie请求：前后端都需要设置字段，另外需注意：所带cookie为跨域请求接口所在域的cookie，而非当前页。<br>目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。</p><h3 id="1、-前端设置："><a href="#1、-前端设置：" class="headerlink" title="1、 前端设置："></a>1、 前端设置：</h3><h4 id="1）原生ajax"><a href="#1）原生ajax" class="headerlink" title="1）原生ajax"></a>1）原生ajax</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 前端设置是否带cookie</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line">示例代码：</span><br><span class="line"></span><br><span class="line">var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容</span><br><span class="line"></span><br><span class="line">// 前端设置是否带cookie</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'http://www.domain2.com:8080/login'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">xhr.send(<span class="string">'user=admin'</span>);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2）jQuery-ajax"><a href="#2）jQuery-ajax" class="headerlink" title="2）jQuery ajax"></a>2）jQuery ajax</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    ...</span><br><span class="line">   xhrFields: &#123;</span><br><span class="line">       withCredentials: <span class="literal">true</span>    // 前端设置是否带cookie</span><br><span class="line">   &#125;,</span><br><span class="line">   crossDomain: <span class="literal">true</span>,   // 会让请求头中包含跨域的额外信息，但不会含cookie</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3）vue框架在vue-resource封装的ajax组件中加入以下代码："><a href="#3）vue框架在vue-resource封装的ajax组件中加入以下代码：" class="headerlink" title="3）vue框架在vue-resource封装的ajax组件中加入以下代码："></a>3）vue框架在vue-resource封装的ajax组件中加入以下代码：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.options.credentials = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="2、-服务端设置："><a href="#2、-服务端设置：" class="headerlink" title="2、 服务端设置："></a>2、 服务端设置：</h3><p>若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。</p><h4 id="1）Java后台："><a href="#1）Java后台：" class="headerlink" title="1）Java后台："></a>1）Java后台：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 导入包：import javax.servlet.http.HttpServletResponse;</span><br><span class="line"> * 接口参数中定义：HttpServletResponse response</span><br><span class="line"> */</span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"http://www.domain1.com"</span>);  // 若有端口需写全（协议+域名+端口）</span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><h4 id="2）Nodejs后台示例："><a href="#2）Nodejs后台示例：" class="headerlink" title="2）Nodejs后台示例："></a>2）Nodejs后台示例：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var http = require(<span class="string">'http'</span>);</span><br><span class="line">var server = http.createServer();</span><br><span class="line">var qs = require(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="keyword">function</span>(req, res) &#123;</span><br><span class="line">    var postData = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    // 数据块接收中</span><br><span class="line">    req.addListener(<span class="string">'data'</span>, <span class="keyword">function</span>(chunk) &#123;</span><br><span class="line">        postData += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 数据接收完毕</span><br><span class="line">    req.addListener(<span class="string">'end'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        postData = qs.parse(postData);</span><br><span class="line"></span><br><span class="line">        // 跨域后台设置</span><br><span class="line">        res.writeHead(200, &#123;</span><br><span class="line">            <span class="string">'Access-Control-Allow-Credentials'</span>: <span class="string">'true'</span>,     // 后端允许发送Cookie</span><br><span class="line">            <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'http://www.domain1.com'</span>,    // 允许访问的域（协议+域名+端口）</span><br><span class="line">            <span class="string">'Set-Cookie'</span>: <span class="string">'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'</span>   // HttpOnly:脚本无法读取cookie</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        res.write(JSON.stringify(postData));</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line">console.log(<span class="string">'Server is running at port 8080...'</span>);</span><br></pre></td></tr></table></figure><h2 id="七、-nginx代理跨域"><a href="#七、-nginx代理跨域" class="headerlink" title="七、 nginx代理跨域"></a>七、 nginx代理跨域</h2><h3 id="1、-nginx配置解决iconfont跨域"><a href="#1、-nginx配置解决iconfont跨域" class="headerlink" title="1、 nginx配置解决iconfont跨域"></a>1、 nginx配置解决iconfont跨域</h3><p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  add_header Access-Control-Allow-Origin *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2、-nginx反向代理接口跨域"><a href="#2、-nginx反向代理接口跨域" class="headerlink" title="2、 nginx反向代理接口跨域"></a>2、 nginx反向代理接口跨域</h3><p>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><p>nginx具体配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http://www.domain2.com:8080;  <span class="comment">#反向代理</span></span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; <span class="comment">#修改cookie里域名</span></span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span></span><br><span class="line">        add_header Access-Control-Allow-Origin http://www.domain1.com;  <span class="comment">#当前端只跨域不带cookie时，可为*</span></span><br><span class="line">        add_header Access-Control-Allow-Credentials <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-前端代码示例："><a href="#1-前端代码示例：" class="headerlink" title="1) 前端代码示例："></a>1) 前端代码示例：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">// 前端开关：浏览器是否读写cookie</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">// 访问nginx中的代理服务器</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'http://www.domain1.com:81/?user=admin'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><h3 id="2-Nodejs后台示例："><a href="#2-Nodejs后台示例：" class="headerlink" title="2) Nodejs后台示例："></a>2) Nodejs后台示例：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var http = require(<span class="string">'http'</span>);</span><br><span class="line">var server = http.createServer();</span><br><span class="line">var qs = require(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="keyword">function</span>(req, res) &#123;</span><br><span class="line">    var params = qs.parse(req.url.substring(2));</span><br><span class="line"></span><br><span class="line">    // 向前台写cookie</span><br><span class="line">    res.writeHead(200, &#123;</span><br><span class="line">        <span class="string">'Set-Cookie'</span>: <span class="string">'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'</span>   // HttpOnly:脚本无法读取</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    res.write(JSON.stringify(params));</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line">console.log(<span class="string">'Server is running at port 8080...'</span>);</span><br></pre></td></tr></table></figure><h2 id="八、-Nodejs中间件代理跨域"><a href="#八、-Nodejs中间件代理跨域" class="headerlink" title="八、 Nodejs中间件代理跨域"></a>八、 Nodejs中间件代理跨域</h2><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发。</p><h3 id="1、-非vue框架的跨域（2次跨域）"><a href="#1、-非vue框架的跨域（2次跨域）" class="headerlink" title="1、 非vue框架的跨域（2次跨域）"></a>1、 非vue框架的跨域（2次跨域）</h3><p>利用node + express + http-proxy-middleware搭建一个proxy服务器。</p><h4 id="1-）前端代码示例："><a href="#1-）前端代码示例：" class="headerlink" title="1.）前端代码示例："></a>1.）前端代码示例：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">// 前端开关：浏览器是否读写cookie</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">// 访问http-proxy-middleware代理服务器</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'http://www.domain1.com:3000/login?user=admin'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><h4 id="2-）中间件服务器："><a href="#2-）中间件服务器：" class="headerlink" title="2.）中间件服务器："></a>2.）中间件服务器：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var express = require(<span class="string">'express'</span>);</span><br><span class="line">var proxy = require(<span class="string">'http-proxy-middleware'</span>);</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/'</span>, proxy(&#123;</span><br><span class="line">    // 代理跨域目标接口</span><br><span class="line">    target: <span class="string">'http://www.domain2.com:8080'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    // 修改响应头信息，实现跨域并允许带cookie</span><br><span class="line">    onProxyRes: <span class="keyword">function</span>(proxyRes, req, res) &#123;</span><br><span class="line">        res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://www.domain1.com'</span>);</span><br><span class="line">        res.header(<span class="string">'Access-Control-Allow-Credentials'</span>, <span class="string">'true'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // 修改响应信息中的cookie域名</span><br><span class="line">    cookieDomainRewrite: <span class="string">'www.domain1.com'</span>  // 可以为<span class="literal">false</span>，表示不修改</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br><span class="line">console.log(<span class="string">'Proxy server is listen at port 3000...'</span>);</span><br></pre></td></tr></table></figure><h4 id="3-）Nodejs后台同（六：nginx）"><a href="#3-）Nodejs后台同（六：nginx）" class="headerlink" title="3.）Nodejs后台同（六：nginx）"></a>3.）Nodejs后台同（六：nginx）</h4><h3 id="2、-vue框架的跨域（1次跨域）"><a href="#2、-vue框架的跨域（1次跨域）" class="headerlink" title="2、 vue框架的跨域（1次跨域）"></a>2、 vue框架的跨域（1次跨域）</h3><p>利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。</p><p>webpack.config.js部分配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;&#125;,</span><br><span class="line">    module: &#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">        proxy: [&#123;</span><br><span class="line">            context: <span class="string">'/login'</span>,</span><br><span class="line">            target: <span class="string">'http://www.domain2.com:8080'</span>,  // 代理跨域目标接口</span><br><span class="line">            changeOrigin: <span class="literal">true</span>,</span><br><span class="line">            cookieDomainRewrite: <span class="string">'www.domain1.com'</span>  // 可以为<span class="literal">false</span>，表示不修改</span><br><span class="line">        &#125;],</span><br><span class="line">        noInfo: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>webpack+vue-cil之proxyTable实现前端跨域请求后台接口在config-index.js里的dev里添加<br>proxyTable配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dev: &#123;</span><br><span class="line"></span><br><span class="line">   // Paths</span><br><span class="line">   assetsSubDirectory: <span class="string">'static'</span>,</span><br><span class="line">   assetsPublicPath: <span class="string">'/'</span>,</span><br><span class="line">   proxyTable: &#123;</span><br><span class="line">     <span class="string">'/yanphone-rest'</span>: &#123;</span><br><span class="line">       target: <span class="string">'https://www.domain2.com:8080'</span>,  //目标接口域名</span><br><span class="line">       changeOrigin: <span class="literal">true</span>,  //是否跨域</span><br><span class="line">       secure: <span class="literal">false</span>,</span><br><span class="line">       // pathRewrite: &#123;</span><br><span class="line">       //   <span class="string">'^/yanphone-rest'</span>: <span class="string">'/yanphone-rest'</span>   //重写接口</span><br><span class="line">       // &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="九、-WebSocket协议跨域"><a href="#九、-WebSocket协议跨域" class="headerlink" title="九、 WebSocket协议跨域"></a>九、 WebSocket协议跨域</h2><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><h3 id="1-）前端代码："><a href="#1-）前端代码：" class="headerlink" title="1.）前端代码："></a>1.）前端代码：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;user input：&lt;input <span class="built_in">type</span>=<span class="string">"text"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script src=<span class="string">"./socket.io.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var socket = io(<span class="string">'http://www.domain2.com:8080'</span>);</span><br><span class="line"></span><br><span class="line">// 连接成功处理</span><br><span class="line">socket.on(<span class="string">'connect'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    // 监听服务端消息</span><br><span class="line">    socket.on(<span class="string">'message'</span>, <span class="keyword">function</span>(msg) &#123;</span><br><span class="line">        console.log(<span class="string">'data from server: ---&gt; '</span> + msg); </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 监听服务端关闭</span><br><span class="line">    socket.on(<span class="string">'disconnect'</span>, <span class="function"><span class="title">function</span></span>() &#123; </span><br><span class="line">        console.log(<span class="string">'Server socket has closed.'</span>); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">document.getElementsByTagName(<span class="string">'input'</span>)[0].onblur = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    socket.send(this.value);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="2-）Nodejs-socket后台："><a href="#2-）Nodejs-socket后台：" class="headerlink" title="2.）Nodejs socket后台："></a>2.）Nodejs socket后台：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var http = require(<span class="string">'http'</span>);</span><br><span class="line">var socket = require(<span class="string">'socket.io'</span>);</span><br><span class="line"></span><br><span class="line">// 启http服务</span><br><span class="line">var server = http.createServer(<span class="keyword">function</span>(req, res) &#123;</span><br><span class="line">    res.writeHead(200, &#123;</span><br><span class="line">        <span class="string">'Content-type'</span>: <span class="string">'text/html'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line">console.log(<span class="string">'Server is running at port 8080...'</span>);</span><br><span class="line"></span><br><span class="line">// 监听socket连接</span><br><span class="line">socket.listen(server).on(<span class="string">'connection'</span>, <span class="keyword">function</span>(client) &#123;</span><br><span class="line">    // 接收信息</span><br><span class="line">    client.on(<span class="string">'message'</span>, <span class="keyword">function</span>(msg) &#123;</span><br><span class="line">        client.send(<span class="string">'hello：'</span> + msg);</span><br><span class="line">        console.log(<span class="string">'data from client: ---&gt; '</span> + msg);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 断开处理</span><br><span class="line">    client.on(<span class="string">'disconnect'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(<span class="string">'Client socket has closed.'</span>); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、通过jsonp跨域&quot;&gt;&lt;a href=&quot;#一、通过jsonp跨域&quot; class=&quot;headerlink&quot; title=&quot;一、通过jsonp跨域&quot;&gt;&lt;/a&gt;一、通过jsonp跨域&lt;/h2&gt;&lt;p&gt;通常为了减轻web服务器的负载，我们把js、css，img等静态资源
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>判断数据类型的方法</title>
    <link href="http://yoursite.com/2018/08/27/data-type/"/>
    <id>http://yoursite.com/2018/08/27/data-type/</id>
    <published>2018-08-27T02:26:09.444Z</published>
    <updated>2018-08-27T02:26:09.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1.typeof"></a>1.typeof</h2><p>typeof是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 6 种：number、boolean、string、object、undefined、function 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typeof <span class="string">''</span>; // string 有效</span><br><span class="line">typeof 1; // number 有效</span><br><span class="line">typeof Symbol(); // symbol 有效</span><br><span class="line">typeof <span class="literal">true</span>; //boolean 有效</span><br><span class="line">typeof undefined; //undefined 有效</span><br><span class="line">typeof new Function(); // <span class="keyword">function</span> 有效</span><br><span class="line">typeof null; //object 无效</span><br><span class="line">typeof [] ; //object 无效</span><br><span class="line">typeof new Date(); //object 无效</span><br><span class="line">typeof new RegExp(); //object 无效</span><br></pre></td></tr></table></figure></p><p>有些时候，typeof 操作符会返回一些令人迷惑但技术上却正确的值：</p><ul><li>对于基本类型，除 null 以外，均可以返回正确的结果。</li><li>对于引用类型，除 function 以外，一律返回 object 类型。</li><li>对于 null ，返回 object 类型。</li><li>对于 function 返回 function 类型。 </li></ul><p>其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型，没有错，但不是我们想要的结果。</p><h2 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2.instanceof"></a>2.instanceof</h2><p>instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型。 </p><p>当 A 的 <strong>proto</strong> 指向 B 的 prototype 时，就认为 A 就是 B 的实例，注意：instanceof 后面一定要是对象类型，并且大小写不能错，该方法适合一些条件选择或分支。我们再来看几个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[] instanceof Array; //<span class="literal">true</span></span><br><span class="line">&#123;&#125; instanceof Object;//<span class="literal">true</span></span><br><span class="line">new Date() instanceof Date;//<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>()&#123;&#125;;</span><br><span class="line">new Person() instanceof Person;</span><br><span class="line"></span><br><span class="line">[] instanceof Object; //<span class="literal">true</span></span><br><span class="line">new Date() instanceof Object;//<span class="literal">true</span></span><br><span class="line">new Person instanceof Object;//<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>虽然 instanceof 能够判断出 [ ] 是Array的实例，但它认为 [ ] 也是Object的实例。因为[] 的 proto 直接指向Array.prototype，间接指向 Object.prototype，所以按照 instanceof 的判断规则，[] 就是Object的实例。因此，instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。<br>ECMAScript 5 新增了 Array.isArray() 方法。这个方法的目的是最终确定某个值到底是不是数组。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 下面的函数调用都返回 <span class="literal">true</span></span><br><span class="line">Array.isArray([]);</span><br><span class="line">Array.isArray([1]);</span><br><span class="line">Array.isArray(new Array());</span><br></pre></td></tr></table></figure></p><h2 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3.constructor"></a>3.constructor</h2><p>当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后再在 prototype上添加一个 constructor 属性，并让其指向 F 的引用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">alert(c.constructor === Array) ----------&gt; <span class="literal">true</span></span><br><span class="line">alert(d.constructor === Date) -----------&gt; <span class="literal">true</span></span><br><span class="line">alert(e.constructor === Function) -------&gt; <span class="literal">true</span></span><br><span class="line">注意： constructor 在类继承时会出错</span><br><span class="line">eg：</span><br><span class="line">      <span class="keyword">function</span> <span class="function"><span class="title">A</span></span>()&#123;&#125;;</span><br><span class="line">      <span class="keyword">function</span> <span class="function"><span class="title">B</span></span>()&#123;&#125;;</span><br><span class="line">      A.prototype = new B(); //A继承自B</span><br><span class="line">      var aObj = new A();</span><br><span class="line">      alert(aobj.constructor === B) -----------&gt; <span class="literal">true</span>;</span><br><span class="line">      alert(aobj.constructor === A) -----------&gt; <span class="literal">false</span>;</span><br><span class="line">而instanceof方法不会出现该问题，对象直接继承和间接继承的都会报<span class="literal">true</span>：</span><br><span class="line">      alert(aobj instanceof B) ----------------&gt; <span class="literal">true</span>;</span><br><span class="line">      alert(aobj instanceof B) ----------------&gt; <span class="literal">true</span>;</span><br><span class="line">言归正传，解决construtor的问题通常是让对象的constructor手动指向自己：</span><br><span class="line">      aobj.constructor = A; //将自己的类赋值给对象的constructor属性</span><br><span class="line">      alert(aobj.constructor === A) -----------&gt; <span class="literal">true</span>;</span><br><span class="line">      alert(aobj.constructor === B) -----------&gt; <span class="literal">false</span>; //基类不会报<span class="literal">true</span>了;</span><br></pre></td></tr></table></figure></p><h2 id="4-toString"><a href="#4-toString" class="headerlink" title="4.toString"></a>4.toString</h2><p>toString 是 Object 原型对象上的方法，使用 call 来调用该方法会返回调用者的类型字符串，格式为 [object,xxx]，xxx 是调用者的数据类型，包括：String、Number、Boolean、Undefined、Null、Function、Date、Array、RegExp、Error、HTMLDocument 等， 基本上，所有的数据类型都可以通过这个方法获取到<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(<span class="string">''</span>) ;   // [object String]</span><br><span class="line">Object.prototype.toString.call(1) ;    // [object Number]</span><br><span class="line">Object.prototype.toString.call(<span class="literal">true</span>) ; // [object Boolean]</span><br><span class="line">Object.prototype.toString.call(Symbol()); //[object Symbol]</span><br><span class="line">Object.prototype.toString.call(undefined) ; // [object Undefined]</span><br><span class="line">Object.prototype.toString.call(null) ; // [object Null]</span><br><span class="line">Object.prototype.toString.call(new Function()) ; // [object Function]</span><br><span class="line">Object.prototype.toString.call(new Date()) ; // [object Date]</span><br><span class="line">Object.prototype.toString.call([]) ; // [object Array]</span><br><span class="line">Object.prototype.toString.call(new RegExp()) ; // [object RegExp]</span><br><span class="line">Object.prototype.toString.call(new Error()) ; // [object Error]</span><br><span class="line">Object.prototype.toString.call(document) ; // [object HTMLDocument]</span><br><span class="line">Object.prototype.toString.call(window) ; //[object global] window是全局对象 global 的引用</span><br></pre></td></tr></table></figure></p><p>需要注意的是，必须通过 call 或 apply 来调用，而不能直接调用 toString ， 从原型链的角度讲，所有对象的原型链最终都指向了 Object， 按照JS变量查找规则，其他对象应该也可以直接访问到 Object 的 toString方法，而事实上，大部分的对象都实现了自身的 toString 方法，这样就可能会导致 Object 的 toString 被终止查找，因此要用 call/apply 来强制调用Object 的 toString 方法。</p><h2 id="5-type"><a href="#5-type" class="headerlink" title="5.$.type()"></a>5.$.type()</h2><p>$.type() 函数用于确定JavaScript内置对象的类型，并返回小写形式的类型名称。</p><p>如果对象是undefined或null，则返回相应的”undefined”或”null”<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="built_in">type</span>( undefined ) === <span class="string">"undefined"</span></span><br><span class="line"></span><br><span class="line">$.<span class="built_in">type</span>() === <span class="string">"undefined"</span></span><br><span class="line"></span><br><span class="line">$.<span class="built_in">type</span>( window.notDefined ) === <span class="string">"undefined"</span></span><br><span class="line"></span><br><span class="line">$.<span class="built_in">type</span>( null ) === <span class="string">"null"</span></span><br></pre></td></tr></table></figure></p><p>如果对象有一个内部属性[[Class]]和一个浏览器的内置对象的 [[Class]] 相同，我们返回相应的 [[Class]] 名字。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="built_in">type</span>( <span class="literal">true</span> ) === <span class="string">"boolean"</span></span><br><span class="line"></span><br><span class="line">$.<span class="built_in">type</span>( 3 ) === <span class="string">"number"</span></span><br><span class="line"></span><br><span class="line">$.<span class="built_in">type</span>( <span class="string">"test"</span> ) === <span class="string">"string"</span></span><br><span class="line"></span><br><span class="line">$.<span class="built_in">type</span>( <span class="function"><span class="title">function</span></span>()&#123;&#125; ) === <span class="string">"function"</span></span><br><span class="line"></span><br><span class="line">$.<span class="built_in">type</span>( [] ) === <span class="string">"array"</span></span><br><span class="line"></span><br><span class="line">$.<span class="built_in">type</span>( new Date() ) === <span class="string">"date"</span></span><br><span class="line"></span><br><span class="line">$.<span class="built_in">type</span>( new Error() ) === <span class="string">"error"</span> // jQuery 1.9 新增支持</span><br><span class="line"></span><br><span class="line">$.<span class="built_in">type</span>( /<span class="built_in">test</span>/ ) === <span class="string">"regexp"</span></span><br></pre></td></tr></table></figure></p><p>参考：<a href="https://blog.csdn.net/liwenfei123/article/details/77978027" target="_blank" rel="noopener">type</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-typeof&quot;&gt;&lt;a href=&quot;#1-typeof&quot; class=&quot;headerlink&quot; title=&quot;1.typeof&quot;&gt;&lt;/a&gt;1.typeof&lt;/h2&gt;&lt;p&gt;typeof是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>小div在大div里面水平垂直都居中的实现方法</title>
    <link href="http://yoursite.com/2018/08/24/block_center/"/>
    <id>http://yoursite.com/2018/08/24/block_center/</id>
    <published>2018-08-24T10:35:16.482Z</published>
    <updated>2018-08-24T10:35:16.483Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、使用定位的方法"><a href="#1、使用定位的方法" class="headerlink" title="1、使用定位的方法"></a>1、使用定位的方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">           width: 300px;</span><br><span class="line">           height: 200px;</span><br><span class="line">           border: 1px solid red;</span><br><span class="line">           position:relative;</span><br><span class="line">           &#125;</span><br><span class="line">.child &#123;</span><br><span class="line">          width: 100px;</span><br><span class="line">          height: 100px;</span><br><span class="line">          border: 1px solid violet;</span><br><span class="line">          position:absolute;</span><br><span class="line">          top: 50%;</span><br><span class="line">          left:50%;</span><br><span class="line">          margin-top: -50px;     /*这里是小盒子高的一半*/</span><br><span class="line">          margin-left: -50px;    /*这里是小盒子宽的一半*/</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>使用定位方法,需要知道子元素的宽高,但是不需要知道父元素的宽高.</p><h3 id="2、利用定位及margin-auto实现"><a href="#2、利用定位及margin-auto实现" class="headerlink" title="2、利用定位及margin:auto实现"></a>2、利用定位及margin:auto实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">          width: 300px;</span><br><span class="line">          height: 200px;</span><br><span class="line">          border: 1px solid red;</span><br><span class="line">          position:relative;</span><br><span class="line">        &#125;</span><br><span class="line">.child &#123;</span><br><span class="line">          width: 100px;</span><br><span class="line">          height: 100px;</span><br><span class="line">          border: 1px solid violet;</span><br><span class="line">          position: absolute;</span><br><span class="line">          margin: auto;</span><br><span class="line">          top: 0;</span><br><span class="line">          left: 0;</span><br><span class="line">          right: 0;</span><br><span class="line">          bottom: 0;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>实现原理是设置margin自动适应,然后设置定位的上下左右都为0,就如四边均衡受力从而实现盒子的居中;</p><h3 id="3、使用display-table-cell"><a href="#3、使用display-table-cell" class="headerlink" title="3、使用display:table-cell;"></a>3、使用display:table-cell;</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">          width: 300px;</span><br><span class="line">          height: 200px;</span><br><span class="line">          border: 1px solid red;</span><br><span class="line">          display: table-cell;</span><br><span class="line">          vertical-align: middle;</span><br><span class="line">           text-align: center;         </span><br><span class="line">        &#125;</span><br><span class="line">.child &#123;</span><br><span class="line">          width: 100px;</span><br><span class="line">          height: 100px;</span><br><span class="line">          border: 1px solid violet;</span><br><span class="line">          display: inline-block;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>实现原理:<br>display:table-cell属性指让标签元素以表格单元格的形式呈现，类似于td标签.<br>组合使用vertical-align,text-align,可以使父元素内的所有行内元素水平垂直居中（也就是将内部的元素设置display:inline-block）</p><h3 id="4、使用伸缩布局display-flex"><a href="#4、使用伸缩布局display-flex" class="headerlink" title="4、使用伸缩布局display:flex"></a>4、使用伸缩布局display:flex</h3>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">          width: 300px;</span><br><span class="line">          height: 200px;</span><br><span class="line">          border: 1px solid red;</span><br><span class="line">          display: flex;</span><br><span class="line">          ustify-content: center;  /*水平居中*/</span><br><span class="line">          align-items: center;      /*垂直居中*/      </span><br><span class="line">        &#125;</span><br><span class="line">.child &#123;</span><br><span class="line">          width: 100px;</span><br><span class="line">          height: 100px;</span><br><span class="line">          border: 1px solid violet;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><h3 id="5、计算四周的间距设置子元素与父元素之间的margin-top和margin-left"><a href="#5、计算四周的间距设置子元素与父元素之间的margin-top和margin-left" class="headerlink" title="5、计算四周的间距设置子元素与父元素之间的margin-top和margin-left;"></a>5、计算四周的间距设置子元素与父元素之间的margin-top和margin-left;</h3>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">          width: 300px;</span><br><span class="line">          height: 200px;</span><br><span class="line">          border: 1px solid red;  </span><br><span class="line">        &#125;</span><br><span class="line">.child &#123;</span><br><span class="line">          width: 100px;</span><br><span class="line">          height: 100px;</span><br><span class="line">          border: 1px solid violet;</span><br><span class="line">          margin-top: 50px;</span><br><span class="line">          margin-left: 100px;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>   最后这种方法需要同时知道父元素与子元素的宽高,不方便日后的维护.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、使用定位的方法&quot;&gt;&lt;a href=&quot;#1、使用定位的方法&quot; class=&quot;headerlink&quot; title=&quot;1、使用定位的方法&quot;&gt;&lt;/a&gt;1、使用定位的方法&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo搭建个人微博</title>
    <link href="http://yoursite.com/2018/08/24/blog-creat/"/>
    <id>http://yoursite.com/2018/08/24/blog-creat/</id>
    <published>2018-08-24T10:35:16.455Z</published>
    <updated>2018-08-24T10:35:16.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整体流程："><a href="#整体流程：" class="headerlink" title="整体流程："></a>整体流程：</h2><ol><li>搭建 Node.js 环境</li><li>搭建 Git 环境</li><li>GitHub 注册和配置</li><li>安装配置 Hexo</li><li>关联 Hexo 与 GitHub Pages</li><li>GitHub Pages 地址解析到个人域名</li><li>Hexo 的常用操作<h2 id="、搭建Node-js-环境"><a href="#、搭建Node-js-环境" class="headerlink" title="-、搭建Node.js 环境"></a>-、搭建Node.js 环境</h2>1.下载Node.js安装文件：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a><br>2.安装node。保持默认设置即可，一路Next，安装很快就结束了。<br>3.按下Win和R，打开运行窗口，在新打开的窗口中输入cmd，敲击回车，打开命令行界面。输入：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node-v</span><br><span class="line">$ npm-v</span><br></pre></td></tr></table></figure></li></ol><p>如果出现以下结果，则说明安装成功。<br><img src="/2018/08/24/blog-creat/node.png" alt="avatar"></p><h2 id="二、搭建-Git-环境"><a href="#二、搭建-Git-环境" class="headerlink" title="二、搭建 Git 环境"></a>二、搭建 Git 环境</h2><p>1、下载git：<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><p>2、安装，默认下一步即可<br>3、测试git安装是否成功<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git --version</span><br></pre></td></tr></table></figure></p><h2 id="三、GitHub-注册和配置"><a href="#三、GitHub-注册和配置" class="headerlink" title="三、GitHub 注册和配置"></a>三、GitHub 注册和配置</h2><p>如果已经拥有账号。请跳过此步。</p><p>1、github注册</p><p>第一步：打开<a href="https://github.com/" target="_blank" rel="noopener">github</a>，输入自己的用户名、邮箱、密码注册一个账号。</p><p>第二步：登陆后点击右上角的“+”号，如图中所示选择。<br><img src="/2018/08/24/blog-creat/github1.png" alt="avatar"><br>进入创建页面，填写好Repository name：<br><img src="/2018/08/24/blog-creat/github2.png" alt="avatar"><br>第三步：代码库设置。创建之后会看到一下界面，选择settings。<br><img src="/2018/08/24/blog-creat/github3.png" alt="avatar"><br>第四步：开启gh-pages功能，向下拖动，直到看见GitHub Pages，如图：<br><img src="/2018/08/24/blog-creat/github4.png" alt="avatar"><br>第五步：点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。 如果你的配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了~ 如果yourname.github.io已经可以正常访问了，那么Github一侧的配置已经全部结束了。</p><h2 id="四、安装配置-Hexo"><a href="#四、安装配置-Hexo" class="headerlink" title="四、安装配置 Hexo"></a>四、安装配置 Hexo</h2><p>1.在自己认为合适的地方创建一个文件夹，这里我以E：/hexo 为例子讲解，首先在E盘目录下创建Hexo文件夹，并在命令行的窗口进入到该目录</p><p><img src="/2018/08/24/blog-creat/hexo1.png" alt="avatar"><br>2.在命令行中输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure></p><p>3.查看Hexo的版本，出现以下表示安装成功<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo version</span><br></pre></td></tr></table></figure></p><p><img src="/2018/08/24/blog-creat/hexo2.png" alt="avatar"><br>4.初始化hexo<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog(项目名字)</span><br><span class="line">$ <span class="built_in">cd</span> blog(项目名字)</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p><p>新建完成后，指定文件夹的目录如下：<br><img src="/2018/08/24/blog-creat/hexo3.png" alt="avatar"><br>5.运行本地 Hexo 服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">或者</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></p><p>然后出现以下,您的网站会在 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 下启动,只是本地哦，别人看不到的：<br><img src="/2018/08/24/blog-creat/hexo4.png" alt="avatar"></p><h2 id="五、关联-Hexo-与-GitHub-Pages"><a href="#五、关联-Hexo-与-GitHub-Pages" class="headerlink" title="五、关联 Hexo 与 GitHub Pages"></a>五、关联 Hexo 与 GitHub Pages</h2><p>1.设置git的username和email：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"xxx"</span></span><br><span class="line">$ git config --global user.email  <span class="string">"xxx"</span></span><br></pre></td></tr></table></figure></p><p>2.生成密钥(可一直回车)，可在/c/Users/you/.ssh/路径下看到刚生成的文件：id_rsa和id_rsa.pub。即公钥和私钥。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></table></figure></p><p>3.在GitHub账户中添加公钥<br>登录GitHub账户在右上角头像里点击下拉里的settings，选择SSH and GPG keys,然后选择右侧的New SSH key，将上一步的id_rsa.pub内容复制到这里的输入框<br>4.配置Deployment<br>同样在_config.yml文件中，找到Deployment，然后按照如下修改，需要注意的是：冒号后面记得空一格！：<br><img src="/2018/08/24/blog-creat/hexo5.png" alt="avatar"><br>5.本地文件提交到GitHub<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 删除旧的 public 文件</span><br><span class="line">hexo clean</span><br><span class="line">// 生成新的 public 文件</span><br><span class="line">hexo generate</span><br><span class="line">或者</span><br><span class="line">hexo g</span><br><span class="line">// 开始部署</span><br><span class="line">hexo deploye</span><br><span class="line">或者</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p><p>如果没有错误产生，此时你本地的代码就已经上传到了Github中。<br>注意1：若上面操作失败，则需要提前安装一个扩展：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>注意2：如果在执行 hexo d 后,出现 error deployer not found:github 的错误（如下），则是因为没有设置好 public key 所致，重新详细设置即可。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Permission denied (publickey). </span><br><span class="line">fatal: Could not <span class="built_in">read</span> from remote repository. </span><br><span class="line">Please make sure you have the correct access rights </span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure></p><h2 id="六、Hexo-的常用操作"><a href="#六、Hexo-的常用操作" class="headerlink" title="六、Hexo 的常用操作"></a>六、Hexo 的常用操作</h2><pre><code>发表一篇文章</code></pre><p>发表一篇文章<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"文章标题"</span></span><br><span class="line">D:\GitHub\Hexo\<span class="built_in">test</span>&gt;hexo new <span class="string">"文章标题"</span></span><br><span class="line">INFO  Created: D:\GitHub\Hexo\<span class="built_in">test</span>\<span class="built_in">source</span>\_posts\文章标题.md</span><br></pre></td></tr></table></figure></p><p>在本地博客文件夹 source_posts 文件夹下看到我们新建的 markdown 文件。</p><p>当然，我们也可以手动添加Markdown文件在source-&gt;_deploy文件夹下，其效果同样可以媲美hexo new</p><p>文章编辑好之后，运行生成、部署命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p><p>当然你也可以执行下面的命令，相当于上面两条命令的效果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure></p><h2 id="七、更改主题"><a href="#七、更改主题" class="headerlink" title="七、更改主题"></a>七、更改主题</h2><p>官方主题库：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p><p>Hexo主题非常，推荐使用 Next 为主题，请阅读 Next 的官方文档（ <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a> ），5 分钟快速安装。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;整体流程：&quot;&gt;&lt;a href=&quot;#整体流程：&quot; class=&quot;headerlink&quot; title=&quot;整体流程：&quot;&gt;&lt;/a&gt;整体流程：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;搭建 Node.js 环境&lt;/li&gt;
&lt;li&gt;搭建 Git 环境&lt;/li&gt;
&lt;li&gt;GitHub 注册和
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用Vue-cli搭建前端项目</title>
    <link href="http://yoursite.com/2018/08/24/vue-cli/"/>
    <id>http://yoursite.com/2018/08/24/vue-cli/</id>
    <published>2018-08-24T10:35:16.417Z</published>
    <updated>2018-08-24T10:35:16.418Z</updated>
    
    <content type="html"><![CDATA[<p>Vue-cli是vue的一个脚手架，我们可以通过它来构建我们的前端项目<br>安装vue-cli的步骤 </p><ol><li>安装nodeJS(已经集成npm) </li><li>node –v ; npm –v查看是否成功安装 </li><li>配置环境变量，找到npm所在的路径（\username\AppData\Roaming\npm）文件可能隐藏,将其放在path中（一般会自动添加） </li><li>安装vue-cli： npm install –g vue-cli </li><li>创建项目 vue init webpack my-project </li><li>选择项目的一些配置（Y/n）<br>注：<br>npm install -g vue-cli<br>-g表示全局安装, vue-cli是模块,全局安装的模块可以在命令行直接使用.</li></ol><p>vue init webpack my-project<br>创建一个基于”webpack”的项目,后面是项目名,<br>执行命令cd my-project </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vue-cli是vue的一个脚手架，我们可以通过它来构建我们的前端项目&lt;br&gt;安装vue-cli的步骤 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装nodeJS(已经集成npm) &lt;/li&gt;
&lt;li&gt;node –v ; npm –v查看是否成功安装 &lt;/li&gt;
&lt;li&gt;配置环境变量，找
      
    
    </summary>
    
    
  </entry>
  
</feed>
